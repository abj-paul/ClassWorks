* Creational Pattern
** Factory Method
** Singleton
** Builder
** Abstract Factory
** Lazy Instantiation
* Structural Pattern ****
** Composite
- Primitives/Leaf
- Container/Composite
- Component

Now each class needs to keep track of which classes are primitives and which classes are container and treat them differently. This adds complexity and duplication to the code, and it also causes the developer to use ~instanceof~ keywords 

As it is a hierarchical structure, each composite must keep a reference of its parent composite. In practice, we keep the childNode field and update it for every addComposite() and deleteComposite() operation.

The component class should contain as much methods as possible because the goal of composite pattern was to allow clients use components without caring whether it is a primitive or composite. If primitives don't support those methods, it can just overwrite those methods to perform no operations.
- Transparency vs Security Trade-off
*** Disadvantage
It is difficult to enforce constraints. Sometimes we want certain composites to have some constraints. But with composite pattern, everything is dealt from the top level component interface so it becomes hard. In those cases, we can only perform runtime checks.

** Decorator
** Facade
As we apply patterns, the subsystems become complex as more and more classes appear. So for outside systems that don't require customization, we provide a single general interface of our subsystem using facade.
If an outsider class needs more customized version of a class, they are also free to enter the subsystem.
It is used to reduce ~client-subsystem~ coupling. It can also be used to reduce subsystem-subsystem coupling.

- ~Layered Structure:~ OSI model shows an interesting example of facade. We provide general interface for each subsystem. The general interfaces should directly communicate with each other to reduce coupling.
** Strategy
* Behavioral Pattern
** Observer
** Mediator
** Template
** Chain of Responsibility
- HelpHandler: Parent class or mixing class. 
- Candidate classes: Possible candidates to provide help. Each class has a successor reference.

  HelpHandler class has a default operation named handleHelp(). This method forwards to its successor by default. The candidates can either overwrite this method or use the default implementation.

  It adds the flexibility of finding the appropriate candidate at ~runtime~, as the Successors are dynamically assigned at the time of candidate object creation.

  We can leverage existing chain instead of making new ones. For example, chains are created in composite pattern. We can use that chain to hangle requests.

  Handling Request: It is good to send a Request object instead of code-string or integers.

  Chain of Responsibility is often applied in conjunction with Composite (163)
There, a component's parent can act as its successor
* Sources
[[https://www.youtube.com/watch?v=v9ejT8FO-7I&list=PLrhzvIcii6GNjpARdnO4ueTUAVR9eMBpc][Christopher Okravi Design Pattern Videos]]
* Question
1. Should composite pattern store parent reference or children reference?

